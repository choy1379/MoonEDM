'use strict';

const http = require('https');
// const URL = require('url').URL;
const url = require('url');
const querystring = require('querystring');
const Promise = require('bluebird');

// regex match youtube id
const idMatch = /(?:youtu\.be\/|youtube\.com\/(?:v\/|(?:watch|embed).*?[&\?]v=))([^#&\?]{11})/;
// get youtube url (from url or id)
function getId(url) {
  return idMatch.test(url) ? idMatch.exec(url)[1] : url;
}

// construct a decipher function for the signature from the player js
function getDecipher(playerjs) {
  return new Promise(function (resolve, reject) {
    http.get(`https://www.youtube.com${playerjs}`, (res) => {
      var body = [];
      res.on('data', (chunk) => body.push(chunk));
      res.on('end', () => {
        // request response body
        body = Buffer.concat(body).toString();

        // since the script is minified and obfuscated
        // we can't search specific function names (since they change)
        // instead we will attempt to match code structure

        // generic js variable identifier
        const v = '[$A-Z_a-z][$A-Z_a-z0-9]*';

        // escape regex
        function escape(regex) {
          return regex.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        // find 'B' in this text: A.set("signature", B(C));
        const reFnName1 = new RegExp(`${v}\\.set\\s*\\("signature",\\s*(${v})\\s*\\(\\s*${v}\\s*\\)\\s*\\)`);
        // get function name
        var fnName;
        if (reFnName1.test(body)) {
          fnName = reFnName1.exec(body)[1];
        }
        // error out if no function name found
        if (!fnName) throw new Error(`${playerjs}: unparsable cipher js`);

        // find body of function in one of the forms:
        // 'function B(C) { ... }'
        // 'var B = function(C) { ... }'
        // ', B = function(C) { ... }'
        const reFnBody1 = new RegExp(`\\bfunction\\s+${escape(fnName)}\\s*\\(\\s*${v}\\s*\\)\\s*{(.*?)}`);
        const reFnBody2 = new RegExp(`(?:\\bvar\\s+|[,;]\\s*)${escape(fnName)}\\s*=\\s*function\\s*\\(\\s*${v}\\s*\\)\\s*{(.*?)}`);
        // get function body
        var fnBody;
        if (reFnBody1.test(body)) {
          fnBody = reFnBody1.exec(body)[1];
        } else if (reFnBody2.test(body)) {
          fnBody = reFnBody2.exec(body)[1];
        }
        // error out if no function body found
        if (!fnBody) throw new Error(`${playerjs}: no cipher function found '${fnName}'`);

        // split function into commands
        var commands = fnBody.split(/\s*;\s*/);
        commands = commands.slice(1, commands.length);

        // command regex 'A.B(c, D)'
        // 'A': util object name
        // 'B': util function name (obfuscated command name)
        // 'C': command parameter
        const reCmd = new RegExp(`(${v})\\s*.\\s*(${v})\\s*\\(\\s*${v}\\s*(?:,\\s*(\\d+)\\s*)?\\)`);
        // get command object name
        var cmdObjName;
        if (reCmd.test(commands[0])) {
          cmdObjName = reCmd.exec(commands[0])[1];
        }
        // error out if not command object name found
        if (!cmdObjName) throw new Error(`${playerjs}: no cipher function command object name found '${fnName} {${fnBody}}'`);

        // find object containing command functions in the form:
        // 'var A = { ... };'
        // where A is the command object name
        const reObfCmds = new RegExp(`\\bvar\\s+${escape(cmdObjName)}\\s*=\\s*{\\s*([\\s\\S]*?)\\s*};`);
        // get command object name
        var cmdObjBody;
        if (reObfCmds.test(body)) {
          cmdObjBody = reObfCmds.exec(body)[1];
        }
        // error out if no command object body found
        if (!cmdObjBody) throw new Error(`${playerjs}: no cipher function command object found '${cmdObjName}'`);

        // loop through mapping obfuscated commands
        const map = {};
        const cipher = [];
        for (var cmd of commands) {
          // get obfuscated command name
          var obf;
          var param;
          if (reCmd.test(cmd)) {
            var exec = reCmd.exec(cmd);
            obf = exec[2];
            param = exec.length >= 2 ? parseInt(reCmd.exec(cmd)[3]) : 0;
          }
          // error out if no util object name found
          if (!obf) throw new Error(`${playerjs}: no cipher function command found '${cmd}'`);

          // if we haven't mapped the command then search for and map it
          if (!map.hasOwnProperty(obf)) {
            // searching command object body for function in the form:
            // '... A: function (...) { ... } ...'
            // where A is the obfuscated name we found
            const reObfCmdFnBody = new RegExp(`\\b${escape(obf)}\\s*:\\s*function\\s*\\([^()]*\\)\\s*{\\s*([^{}]*)\\s*}`);
            // get command function body
            var obfCmdFnBody;
            if (reObfCmdFnBody.test(cmdObjBody)) {
              obfCmdFnBody = reObfCmdFnBody.exec(cmdObjBody)[0];
            }
            // error out if no command function body found
            if (!obfCmdFnBody) throw new Error(`${playerjs}: no cipher function command '${obf}' found in '${cmdObjName} {${cmdObjBody}}'`);

            // map functions based on content
            if (obfCmdFnBody.indexOf('reverse') > -1) {
              map[obf] = 'reverse';
            } else if (obfCmdFnBody.indexOf('splice') > -1) {
              map[obf] = 'splice';
            } else {
              map[obf] = 'swap';
            }
          }

          // push mapped function name and parameter to cipher array
          cipher.push([map[obf], param]);
        }

        // cipher function commands
        const cmds = {
          // reverse array
          reverse: function (a) {
            a.reverse();
          },
          // swap a[0] and a[n] values
          swap: function (a, n) {
            const c = a[0];
            a[0] = a[n % a.length];
            a[n] = c;
          },
          // splice array between 0 and n
          splice: function (a, n) {
            a.splice(0, n);
          }
        };
        // return constructed decipher function
        const decipher = function (signature) {
          var a = signature.split('');

          for (var cmd of cipher) {
            const cmdFn = cmds[cmd[0]];
            const param = cmd[1];
            cmdFn(a, param);
          }

          return a.join('');
        };
        resolve(decipher);
      });
      res.on('error', reject);
    }).end();
  });
}

// get audio stream from id
function getAudio(id) {
  id = getId(id);
  return new Promise(function (resolve, reject) {
    const req = http.get(`https://www.youtube.com/watch?v=${id}`, (res) => {
      var body = [];
      res.on('data', (chunk) => body.push(chunk));
      res.on('end', () => {
        body = Buffer.concat(body).toString();

        // use regex to avoid having to parse the xml
        const confString = /ytplayer\.config.*?=.*?({.*?});/.exec(body)[1];
        const conf = JSON.parse(confString);

        const formats = conf.args.adaptive_fmts.split(',').map((format) => {
          const res = {};
          format.split('&').forEach((val) => {
            const index = val.indexOf('=');
            if (index > -1) {
              const key = querystring.unescape(val.slice(0, index));
              const value = querystring.unescape(val.slice(index + 1, val.length));
              res[key] = value;
            }
          });
          return res;
        });

        const audioFormats = formats.filter((format) => format.type.indexOf('audio/') == 0);
        const audio = audioFormats.sort((a, b) => b.bitrate - a.bitrate)[0];

        const audioURL = url.parse(audio.url, true);
        audioURL.query['alr'] = 'yes';
        audioURL.query['ratebypass'] = 'yes';
        audioURL.query['c'] = conf.args.c;
        audioURL.query['cver'] = conf.args.cver;
        audioURL.query['rn'] = '1';
        audioURL.query['rbuf'] = '0';

        // check for a signature
        if (audio.s) {
          // if a signature is required run decipher
          const playerjs = conf.assets.js;
          getDecipher(playerjs).then((decipher) => {
            audioURL.query['signature'] = decipher(audio.s);
            audioURL.query = querystring.stringify(audioURL.query);
            audioURL.search = `?${audioURL.query}`;
            resolve(audioURL.format());
          }).catch((error) => {
            reject(error);
          });
        } else {
          // otherwise return url
          audioURL.query = querystring.stringify(audioURL.query);
          audioURL.search = `?${audioURL.query}`;
          resolve(audioURL.format());
        }
      });
      res.on('error', reject);
    });
    req.end();
  });
}

module.exports = function (link) {
  return getAudio(link);
};
